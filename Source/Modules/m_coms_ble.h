/**
 * Copyright (c) 2016 - 2018, Nordic Semiconductor ASA
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 * 
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 * 
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 * 
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 * 
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

/**
 * @defgroup MOD_COMS_BLE BLE communications submodule
 * @ingroup ble
 * @{
 * @brief Communications submodule that is used to deal with BTLE and HID over GATT specifics.
 *
 *
 */
#ifndef __M_COMS_BLE_H__
#define __M_COMS_BLE_H__

#include <stdbool.h>
#include <stdint.h>

#include "app_scheduler.h"
#include "app_util.h"
#include "ble_types.h"
#include "ble_hids.h"
#include "ble_gap.h"
#include "ble_gatts.h"
#include "peer_manager.h"

struct ble_hid_db_s;

#define BOOT_KEYBOARD_LEN 8 /** See HID 1.11 spec Appendix B.1 (Boot keyboard descriptor). */

/**@brief Event types generated by this module. */
typedef enum
{
    M_COMS_BLE_EVT_CONNECTED,     /**< Connected. */
    M_COMS_BLE_EVT_DISCONNECTED,  /**< Disconnected. */
    M_COMS_BLE_EVT_DATA_RECEIVED, /**< Data received. */
    M_COMS_BLE_EVT_READ_REQ,      /**< Read request received. */
    M_COMS_BLE_EVT_CONN_UPDATE,   /**< Connection parameter update. */
    M_COMS_BLE_EVT_CONN_SECURED,  /**< Connection secured. */
    M_COMS_BLE_EVT_ADV,           /**< Non-Bondable advertising is running. */
    M_COMS_BLE_EVT_ADV_BONDABLE,  /**< Bondable advertising is running. */
    M_COMS_BLE_EVT_ADV_TIMEOUT,   /**< Advertising has timed out. */
    M_COMS_BLE_EVT_ADDR_CHANGED,  /**< Address has changed. */
    M_COMS_BLE_EVT_PASSKEY_REQ,   /**< Passkey requested. */
    M_COMS_BLE_EVT_OOBKEY_REQ,    /**< OOB key requested. */
    M_COMS_BLE_EVT_ALERT,         /**< Immediate Alert level changed. */
    M_COMS_BLE_EVT_TX_COMPLETE,   /**< Transmission complete. */
    M_COMS_BLE_EVT_MTU_CHANGED,   /**< Connection MTU has changed. */
    M_COMS_BLE_EVT_SHUTDOWN       /**< BLE Shutdown complete. */
} m_coms_ble_evt_type_t;

/**@brief Data received event details. */
typedef struct
{
    uint8_t   interface_idx; /**< The interface on which the data was received. */
    uint8_t   report_type;   /**< Type of report: input, output, or feature. */
    uint8_t   report_idx;    /**< The report index on which the data was received. */
    uint8_t   len;           /**< Length of received data. */
    uint8_t * data;          /**< Received data. */
} m_coms_ble_evt_data_recv_t;

/**@brief Read request event details. */
typedef struct
{
    uint8_t   interface_idx; /**< The interface in which the read report is. */
    uint8_t   report_idx;    /**< The report index which is read. */
} m_coms_ble_evt_read_req_t;

/**@brief Connection update event details. */
typedef struct
{
    uint16_t min_conn_interval;   /**< Min connection interval [1.25 ms units] */
    uint16_t max_conn_interval;   /**< Max connection interval [1.25 ms units] */
    uint16_t slave_latency;       /**< Slave latency. */
    uint16_t supervision_timeout; /**< Link time-out [10 ms units]. */
} m_coms_ble_evt_conn_update_t;

/**@brief Immediate Alert details. */
typedef struct
{
    uint8_t level;               /**< Alert level. */
    uint16_t conn_handle;        /**< Connection handle. */
} m_coms_ble_evt_alert_t;

/**@brief TX Complete event details. */
typedef struct
{
    uint8_t count;              /**< Number of transmitted packets. */
} m_coms_ble_evt_tx_complete_t;

/**@brief MTU Changed event details. */
typedef struct
{
    uint8_t effective_mtu;      /**< Effective MTU of the connection. */
} m_coms_ble_evt_mtu_changed_t;

/**@brief Connection state event details. */
typedef struct
{
    uint16_t conn_handle;       /**< Connection handle. */
    pm_peer_id_t peer_id;       /**< Peer ID. */
} m_coms_ble_evt_conn_data_t;

/**@brief Advertising state event details. */
typedef struct
{
    pm_peer_id_t peer_id;       /**< Peer ID. */
} m_coms_ble_evt_adv_data_t;

/**@brief Event structs generated by this module. */
typedef struct
{
    m_coms_ble_evt_type_t type;
    union
    {
        m_coms_ble_evt_data_recv_t    data_received;
        m_coms_ble_evt_read_req_t     read_req;
        m_coms_ble_evt_conn_update_t  conn_update;
        m_coms_ble_evt_alert_t        alert;
        m_coms_ble_evt_tx_complete_t  tx_complete;
        m_coms_ble_evt_mtu_changed_t  mtu_changed;
        m_coms_ble_evt_conn_data_t    conn_data;
        m_coms_ble_evt_adv_data_t     adv_data;
    } data;
} m_coms_ble_evt_t;

/**@brief When in BLE HID (HID over GATT) boot mode, only keyboard and mouse packets of a specified format can be sent.
 *
 * @note Bitmask type enum: valid values are powers of 2.
 */
typedef enum
{
    ble_boot_pkt_keyboard = 0x01, /**< Keyboard boot report. */
    ble_boot_pkt_mouse    = 0x02, /**< Mouse boot report. */
    ble_boot_pkt_none     = 0x80, /**< Not a keyboard/mouse boot report. Will not be sent in boot mode. */
} m_coms_ble_hid_boot_type_t;

/**@brief HID report types. */
typedef enum
{
    hid_report_type_input   = BLE_HIDS_REP_TYPE_INPUT,
    hid_report_type_output  = BLE_HIDS_REP_TYPE_OUTPUT,
    hid_report_type_feature = BLE_HIDS_REP_TYPE_FEATURE
} m_coms_hid_report_type_t;

/**@brief Packet definition used for boot reports.
 * @details The format is specified in USB HID specification, Appendix B: Boot Interface Descriptors.
 */
typedef union
{
    struct
    {
        uint8_t keys[BOOT_KEYBOARD_LEN]; /**< Keyboard keycodes. */
    } keyboard_data;
    struct
    {
        uint8_t buttons; /**< Mouse buttons. */
        int8_t  x_delta; /**< Mouse cursor X delta. */
        int8_t  y_delta; /**< Mouse cursor Y delta. */
    } mouse_data;
} m_coms_hid_boot_pkt_t;

/**@brief When in boot mode (BLE HID), a specific format is used for mouse and keyboard packets regardless of the HID descriptor.
 *        The application will be tasked to reassemble keyboard and mouse packets to fit the specified format.
 * @details For more information, see <a href = "https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.human_interface_device.xml" target = "blank"> this page </a>.
 *        Non-keyboard and mouse packets will be discarded in boot mode.
 *
 * @param[in,out] p_boot_pkt      Resulting boot packet.
 * @param[in]     p_pkt_type      Boot packet type.
 * @param[in]     p_data          Original packet.
 * @param[in]     p_len           Length of the original packet.
 * @param[in]     p_hid_interface The interface index on which the packet was sent.
 * @param[in]     p_report_idx    Report index used.
 */
typedef void (*m_coms_ble_boot_mode_callback)(m_coms_hid_boot_pkt_t *      p_boot_pkt,
                                              m_coms_ble_hid_boot_type_t * p_pkt_type,
                                              const uint8_t *              p_data,
                                              uint8_t                      p_len,
                                              uint8_t                      p_hid_interface,
                                              uint8_t                      p_report_idx);

/**@brief BLE Advertising parameters. */
typedef struct
{
    uint16_t    interval;       /**< Advertising interval (in units of 0.625 ms) */
    uint16_t    timeout;        /**< The advertising time-out in units of seconds used when advertising vs. a resolvable address for reconnecting. */
} m_coms_ble_adv_params_t;

/**@brief BLE bond behavior parameters. */
typedef struct
{
    bool directed_adv;          /** Use directed advertising vs. bonded masters (unless a peer has a private resolvable device address).
                                *  If false, undirected advertising with whitelist is used: this is best suited with change_address = false. */
    bool change_address;        /** Use a new address for each new bond. */
    bool reconnect_all;         /** Attempt to reconnect to all bonded masters. If false, only the last connected master will be advertised against,
                                * unless the bonding procedure is started. */
    bool bond_reconnect_all;    /** Attempt to reconnect to previously bonded masters before advertising as bondable.
                                * If false, bondable advertising is started immediately when the bonding procedure is started. */
} m_coms_ble_bond_params_t;

/**@brief BLE security parameters. */
typedef struct
{
    uint8_t io_capabilities; /**< See BLE_GAP_IO_CAPS. */
} m_coms_ble_sec_params_t;

/**@brief Device Information Service parameters.
 * For more information, see <a href = "https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.device_information.xml" target = "blank"> this page </a>.
 * @note All strings should be in UTF-8 format.
 * @note NULL termination works for all UTF-8 strings, including Chinese, Korean, and Japanese.
 */
typedef struct
{
    char *   device_name;       /**< Null-terminated device name. */
    char *   manufacturer_name; /**< Null-terminated manufacturer name. */
    char *   hw_revision;       /**< Null-terminated hardware revision string. */
    char *   fw_revision;       /**< Null-terminated firmware revision string. */
    char *   serial_number;     /**< Null-terminated serial number string. */
    uint16_t pnp_vendor_id;     /**< Vendor ID. */
    uint8_t  pnp_vendor_id_src; /**< Vendor ID source (BLE_DIS_VENDOR_ID_SRC_BLUETOOTH_SIG or BLE_DIS_VENDOR_ID_SRC_USB_IMPL_FORUM). */
    uint16_t pnp_product_id;    /**< Product ID. */
    uint16_t pnp_product_version;/**< Product version. */
} m_coms_ble_device_info_t;

/**@brief BLE parameters. */
typedef struct
{
    m_coms_ble_device_info_t  device_info; /**< Device information parameters. */
    m_coms_ble_adv_params_t   adv_params;  /**< Advertising parameters. */
    m_coms_ble_bond_params_t  bond_params; /**< Bond behavior parameters. */
    m_coms_ble_sec_params_t   sec_params;  /**< BLE security parameters. */
    uint16_t                  appearance;  /**< Device appearance. See BLE_APPEARANCES. */
    ble_gap_conn_params_t     conn_params; /**< Preferred connection parameters. */

    uint16_t base_hid_version; /**< Defines which HID usage table version this USB descriptor is using. */
    uint8_t  hid_country_code; /**< HID country code. Set to 0 to indicate no specific country. */
    uint8_t  hids_flags;       /**< HID Service flags. See section 4.10 (HID Information Behavior) of HOGP specification. */

    app_sched_event_handler_t     event_handler;        /**< Module event handler. */
    m_coms_ble_boot_mode_callback boot_mode_callback;   /**< Callback function used in HID Boot mode. */
} m_coms_ble_params_t;

/**@brief Function for initializing BLE.
 *
 * @details SoftDevice, Battery service, and Device Information Service will be initialized.
 *          p_ble_params may be 0 if m_coms_ble_init() is called multiple times, as
 *          the parameters are saved in flash. The first execution must always have non-zero parameters.
 *
 * @note SoftDevice will be enabled.
 *
 * @param[in] p_ble_params          BLE parameters. Must be persistent.
 * @param[in] p_hid_db              HID database.
 * @param[in] delete_bonds          If true, all bonds will be deleted during initialization.
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_PARAM
 * @retval NRF_ERROR_NO_MEM
 */
ret_code_t m_coms_ble_init(const m_coms_ble_params_t * p_ble_params,
                           const struct ble_hid_db_s * p_hid_db,
                           bool delete_bonds);

/**@brief Function for setting the OOB key for encrypted OOB connections.
 *
 * @note The key should be 128 bits in a 16-byte array.
 *
 * @param[in] p_key 16-byte byte array or NULL.
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_STATE
 * @retval NRF_ERROR_INVALID_PARAM
 */
ret_code_t m_coms_ble_oobkey_set(uint8_t * p_key);

/**@brief Function for starting the bonding procedure.
 *
 * @details Advertising for a new bond will be started according to parameters (@ref m_coms_ble_init).
 *
 * @note It will cause a disconnect if connected.
 *
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_STATE
 * @retval NRF_ERROR_INTERNAL
 */
ret_code_t m_coms_ble_bonding_start(void);

/**@brief Function for sending a HID report.
 *
 * @note Report length cannot exceed 20 bytes.
 *
 * @param[in] p_data          HID report data to send.
 * @param[in] p_len           Length of report data.
 * @param[in] p_hid_interface HID interface ID.
 * @param[in] p_report_idx    HID Report index.
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_PARAM
 * @retval NRF_ERROR_INVALID_STATE
 * @retval BLE_ERROR_NO_TX_BUFFERS
 */
ret_code_t m_coms_ble_hid_report_send(uint8_t * p_data,
                                      uint8_t   p_len,
                                      uint8_t   p_hid_interface,
                                      uint8_t   p_report_idx);

/**@brief Function for responding to a read request (@ref M_COMS_BLE_EVT_READ_REQ).
 *
 *
 * @param[in] p_data Data to respond with.
 * @param[in] p_len  Length of data.
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_PARAM
 * @retval NRF_ERROR_INVALID_STATE
 */
ret_code_t m_coms_ble_read_respond(uint8_t *p_data, uint8_t p_len);

/**@brief Function for updating the battery level.
 *
 * @param[in] p_batt_level        Battery level.
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INVALID_PARAM
 */
ret_code_t m_coms_ble_battery_level_update(uint8_t p_batt_level);

/**@brief Function for disconnecting.
 *
 * @note The time it takes to disconnect properly depends on connection parameters.
 *
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_x
 */
ret_code_t m_coms_ble_disconnect(void);

/**@brief Function for disconnecting and stopping advertising.
 *
 * @details All activity is stopped. The SoftDevice is <b>not</b> disabled. The necessary bond management is also done when this happens.
 * @return
 * @retval NRF_SUCCESS
 * @retval NRF_ERROR_INTERNAL
 */
ret_code_t m_coms_ble_shutdown(void);

/**@brief Function for checking whether bonding data is kept in flash.
 *
 * @note The module MUST be initialized prior to calling the function.
 *
 * @return True if the keys from the previous connection are stored in flash.
 */
bool m_coms_ble_bond_stored(void);

/**@brief Function for deleting bonding data stored in flash.
 *
 * @return
 * @retval NRF_SUCCESS
 */
ret_code_t m_coms_ble_bond_clear(void);

/**@brief Function for starting advertising.
 *
 * @param[in] bondable  True, if bondable advertising should be started.
 *
 * @return NRF_SUCCESS on success, otherwise error code.
 */
ret_code_t m_coms_ble_advertise(bool bondable);

/**@brief Function for disabling slave latency.
 * @return NRF_SUCCESS on success, otherwise error code.
 */
ret_code_t m_coms_ble_sl_disable(void);

/**@brief Function for enabling slave latency.
 * @return NRF_SUCCESS on success, otherwise error code.
 */
ret_code_t m_coms_ble_sl_enable(void);

#endif /*  __M_COMS_BLE_H__ */

/** @} */
